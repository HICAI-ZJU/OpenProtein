from typing import *
from sklearn.metrics import accuracy_score, mean_squared_error, average_precision_score
from scipy.stats import spearmanr

from openprotein.core import Components


class Metric(metaclass=Components):
    """
    The abstract class for metrics. Three methods such as compute_once, update and reset are defined. Other
    metric classes need to rewrite the compute_once method.
    """

    def __init__(self):
        self.preds = []
        self.trues = []
        self.score = 0
        if self._backend == "pt":
            import torch
            self.is_tensor = torch.is_tensor
            self._conver_to_list = lambda x: x.tolist()

    def compute_once(self, true, pred) -> float:
        """
        Abstract methods, requiring subclasses to implement different evaluation metrics calculations

        Args:
            true : True values or ground-truth.
            pred : Predicted values generated by the model.
        """
        raise NotImplemented

    def update(self):
        """
        Update the score of current metrics.
        """
        self.score = self.compute_once(self.trues, self.preds)

    def reset(self):
        """
        reset internal parameters, such as preds, trues, score.

        Args:
            No Args.
        """
        self.preds.clear()
        self.trues.clear()
        self.score = 0

    def __call__(self, true, pred) -> float:
        true = self._conver_to_list(true)
        pred = self._conver_to_list(pred)
        self.trues.extend(true)
        self.preds.extend(pred)
        self.update()
        return self.score

    def __str__(self):
        return "Current result: {}".format({repr(self): self.score})

class Accuracy(Metric):
    """
    A class to calculate accuracy classification score.

    Args:
        normalize (bool): default=True.
            If ``False``, return the number of correctly classified samples.
            Otherwise, return the fraction of correctly classified samples.
        sample_weight (n_samples)： default=None，array-like of shape (n_samples,)

    Notes:
        In binary classification, this function is equal to the `jaccard_score` function.

    Examples:
        >>> from openprotein.utils import Accuracy
        >>> acc = Accuracy()
        >>> y_true = [0, 2, 1, 3]
        >>> y_pred = [0, 1, 2, 3]
        >>> acc(y_true, y_pred)
        0.5
    """
    def __init__(self, normalize=True, sample_weight=None):
        super().__init__()
        self.normalize = normalize
        self.sample_weight = sample_weight

    def compute_once(self, true: list, pred: list) -> float:
        """
        Calculate the accuracy score for current pred and true

        Args:
            true : True values or ground-truth.
            pred : Predicted values generated by the model.

        Returns:
            Accuracy classification score.
            the fraction of correctly classified samples (float),
            or the number of correctly classified samples (int).

        Examples:
            >>> from openprotein.utils import Accuracy
            >>> acc = Accuracy()
            >>> y_true = [0, 2, 1, 3]
            >>> y_pred = [0, 1, 2, 3]
            >>> acc.compute_once(y_true, y_pred)
            0.5
        """
        return accuracy_score(true, pred, normalize=self.normalize, sample_weight=self.sample_weight)

    def __repr__(self):
        return "Acc"


class MeanSquaredError(Metric):
    """
    A class to calculate mean squared error regression loss.

    Args:
        sample_weight (array-like of shape n_samples):
            Sample weights.
        multioutput ({'raw_values', 'uniform_average'} or array-like of shape n_outputs):
            Defines aggregating of multiple output values.
        squared (bool):
            If True returns MSE value, if False returns RMSE value.

    Examples:
        >>> from openprotein.utils import MeanSquaredError
        >>> mse = MeanSquaredError()
        >>> y_true = [3, -0.5, 2, 7]
        >>> y_pred = [2.5, 0.0, 2, 8]
        >>> mse(y_true, y_pred)
        0.375
    """

    def __init__(self, sample_weight=None, multioutput="uniform_average", squared=True):
        super().__init__()
        self.sample_weight = sample_weight
        self.multioutput = multioutput
        self.squared = squared


    def compute_once(self, true, pred) -> float:
        """
        Calculate the mean squared error regression loss for current pred and true.

        Args:
            true: array-like of shape (n_samples,) or (n_samples, n_outputs)
                Ground truth (correct) target values.
            pred: array-like of shape (n_samples,) or (n_samples, n_outputs)
                Estimated target values.

        Returns:
            loss (float or ndarray of floats):
                A non-negative floating point value (the best value is 0.0), or an
                array of floating point values, one for each individual target.

        Examples:
            >>> from openprotein.utils import MeanSquaredError
            >>> mse = MeanSquaredError()
            >>> y_true = [3, -0.5, 2, 7]
            >>> y_pred = [2.5, 0.0, 2, 8]
            >>> mse.compute_once(y_true, y_pred)
            0.375
        """

        return mean_squared_error(true, pred, sample_weight=self.sample_weight,
                                  multioutput=self.multioutput, squared=self.squared)

    def __repr__(self):
        return "Mse"


class Spearman(Metric):
    """
    A class to calculate a Spearman correlation coefficient with associated p-value.

    Args:
        axis (int or None): int or None, optional
            If axis=0 (default), then each column represents a variable, with
            observations in the rows. If axis=1, the relationship is transposed:
            each row represents a variable, while the columns contain observations.
            If axis=None, then both arrays will be raveled.
        nan_policy : {'propagate', 'raise', 'omit'}, optional
            Defines how to handle when input contains nan.
            The following options are available (default is 'propagate'):
            * 'propagate': returns nan
            * 'raise': throws an error
            * 'omit': performs the calculations ignoring nan values
        alternative : {'two-sided', 'less', 'greater'}, optional
            Defines the alternative hypothesis. Default is 'two-sided'.
            The following options are available:
            * 'two-sided': the correlation is nonzero
            * 'less': the correlation is negative (less than zero)
            * 'greater':  the correlation is positive (greater than zero)

    Examples:
        >>> from openprotein.utils import Spearman
        >>> spe = Spearman()
        >>> y_true = [1, 2, 3, 4, 5]
        >>> y_pred = [5, 6, 7, 8, 7]
        >>> spe(y_true, y_pred)
        0.8207826816681233
    """

    def __init__(self, axis=0, nan_policy='propagate', alternative='two-sided'):
        super().__init__()
        self.axis = axis
        self.nan_policy = nan_policy
        self.alternative = alternative

    def compute_once(self, true, pred) -> float:
        """
        Calculate the spearman correlation coefficient for current pred and true.

        Args:
            true, pred (list): 1D or 2D array_like, pred is optional
                One or two 1-D or 2-D arrays containing multiple variables and
                observations. When these are 1-D, each represents a vector of
                observations of a single variable. For the behavior in the 2-D case,
                see under ``axis``, below.
                Both arrays need to have the same length in the ``axis`` dimension.

        Returns:
            float or ndarray (2-D square)
                Spearman correlation matrix or correlation coefficient (if only 2
                variables are given as parameters. Correlation matrix is square with
                length equal to total number of variables (columns or rows) in ``true``
                and ``pred`` combined.

        References:
            .. [1] Zwillinger, D. and Kokoska, S. (2000). CRC Standard
                Probability and Statistics Tables and Formulae. Chapman & Hall: New
                York. 2000.
                Section  14.7

        Examples:
            >>> from openprotein.utils import Spearman
            >>> spe = Spearman()
            >>> y_true = [1, 2, 3, 4, 5]
            >>> y_pred = [5, 6, 7, 8, 7]
            >>> spe.compute_once(y_true, y_pred)
            0.8207826816681233
        """

        rho, _ = spearmanr(true, pred, axis=self.axis,
                           nan_policy=self.nan_policy, alternative=self.alternative)

        return rho

    def __repr__(self):
        return "Spm"



class AveragePrecisionScore(Metric):
    """
    A class to calculate average precision score.

    Args:
        y_true : ndarray of shape (n_samples,) or (n_samples, n_classes)
            True binary labels or binary label indicators.
        y_score : ndarray of shape (n_samples,) or (n_samples, n_classes)
            Target scores, can either be probability estimates of the positive
            class, confidence values, or non-thresholded measure of decisions
            (as returned by :term:`decision_function` on some classifiers).
        average : {'micro', 'samples', 'weighted', 'macro'} or None, \
                default='macro'
            If ``None``, the scores for each class are returned. Otherwise,
            this determines the type of averaging performed on the data:
            ``'micro'``:
                Calculate metrics globally by considering each element of the label
                indicator matrix as a label.
            ``'macro'``:
                Calculate metrics for each label, and find their unweighted
                mean.  This does not take label imbalance into account.
            ``'weighted'``:
                Calculate metrics for each label, and find their average, weighted
                by support (the number of true instances for each label).
            ``'samples'``:
                Calculate metrics for each instance, and find their average.
            Will be ignored when ``y_true`` is binary.
        pos_label : int or str, default=1
            The label of the positive class. Only applied to binary ``y_true``.
            For multilabel-indicator ``y_true``, ``pos_label`` is fixed to 1.
        sample_weight : array-like of shape (n_samples,), default=None
            Sample weights.

    Returns:
        average_precision : float

    References:
        [1] `Wikipedia entry for the Average precision
           <https://en.wikipedia.org/w/index.php?title=Information_retrieval&
           oldid=793358396#Average_precision>`_

    Examples:
        >>> from openprotein.utils import AveragePrecisionScore
        >>> aps = AveragePrecisionScore()
        >>> y_true = [1, 1, 0, 1]
        >>> y_score = [0.3, 0.4, 0.2, 0.1]
        >>> aps.(y_true, y_score)
        0.9166666666666665
    """

    def __init__(self, average="macro", pos_label=1, sample_weight=None):
        super().__init__()
        self.average = average
        self.pos_label = pos_label
        self.sample_weight = sample_weight

    def compute_once(self, true, score) -> float:
        """
        Calculate the average precision score for current pred and true.

        Args:
            y_true : ndarray of shape (n_samples,) or (n_samples, n_classes)
                True binary labels or binary label indicators.
            y_score : ndarray of shape (n_samples,) or (n_samples, n_classes)
                Target scores, can either be probability estimates of the positive
                class, confidence values, or non-thresholded measure of decisions
                (as returned by :term:`decision_function` on some classifiers).

        Examples:
            >>> from openprotein.utils import AveragePrecisionScore
            >>> aps = AveragePrecisionScore()
            >>> y_true = [1, 1, 0, 1]
            >>> y_score = [0.3, 0.4, 0.2, 0.1]
            >>> aps.compute_once(y_true, y_score)
            0.9166666666666665

            """

        y_score = average_precision_score(true, score)
        return y_score

    def __repr__(self):
        return "AveragePrecisionScore"